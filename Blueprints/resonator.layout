/*
 Coupled lamda/4 resonator.
 
 Coupling point is in the center of coupling area, being offset to the edge of protect layer towards the feedline.
 Schematic:
 
 ===================== <- feedline
  ________x________    <- resonator coupling area 
 |                 |   x - coupling (base) point
*/



#include "wiring.layout"

    int meanderSegmentLength = 250e3;
    double clawPhaseShift = 12.2;
    
int length_from_frequency(double frequency, bool claw) {
    if (claw)
        return (math::sqrt2/2*c/frequency/(math::sqrt(ɛ+1))/1e9/2)*1e6 - 1./180.*clawPhaseShift/frequency/1e9*c/2/math::sqrt(ɛ/2.+1./2.)/2.*1e6;
    else
        return (math::sqrt2/2*c/frequency/(math::sqrt(ɛ+1))/1e9/2)*1e6;
}

void generateStructure(cell* curCell, point cursor,  int width, int tailLen, int length,  int resTurnRad, int layer) {
    
    int curLength = 0;
    point start;
    start.set(cursor.x(), cursor.y());
    
    cursor = wire(curCell, layer, cursor, "r", 200e3, width);
    curLength+=200e3;
    cursor = torusTurn(curCell, layer, cursor, "rd", resTurnRad, width);
    curLength+=resTurnRad*math::pi_2;
    cursor = wire(curCell, layer, cursor, "d", tailLen, width);
    curLength+=tailLen;
    
    cursor.set(start.x(), start.y());
    
    cursor = wire(curCell, layer, cursor, "l", 200e3, width);
    curLength+=200e3;
    cursor = torusTurn(curCell, layer, cursor, "ld", resTurnRad, width);
    curLength+=resTurnRad*math::pi_2;
    cursor = wire(curCell, layer, cursor, "d", 50e3, width);
    curLength+=50e3;
    cursor = torusTurn(curCell, layer, cursor, "dr", resTurnRad, width);
    curLength+=resTurnRad*math::pi_2;
    
        debug(length-curLength);

    int meanderStepLength = 2*meanderSegmentLength+2*math::pi*resTurnRad;
;
    while ((length -curLength)>meanderStepLength) {
        cursor = wire(curCell, layer, cursor, "r", meanderSegmentLength, width);
        cursor = torusTurn(curCell, layer, cursor, "rd", resTurnRad, width);
        cursor = torusTurn(curCell, layer, cursor, "dl", resTurnRad, width);
        cursor = wire(curCell, layer, cursor, "l", meanderSegmentLength, width);
        cursor = torusTurn(curCell, layer, cursor, "ld", resTurnRad, width);
        cursor = torusTurn(curCell, layer, cursor, "dr", resTurnRad, width);
        curLength+=meanderStepLength;
        debug(length-curLength);

    }
    
    if (length - curLength >= meanderSegmentLength+2*resTurnRad*math::pi_2) {
        cursor = wire(curCell, layer, cursor, "r", meanderSegmentLength, width);
        cursor = torusTurn(curCell, layer, cursor, "rd", resTurnRad, width);
        cursor = torusTurn(curCell, layer, cursor, "dl", resTurnRad, width);
        curLength+= meanderSegmentLength+2*resTurnRad*math::pi_2;
        if (length - curLength >= meanderSegmentLength) {
            cursor = wire(curCell, layer, cursor, "l", meanderSegmentLength, width);
            curLength += meanderSegmentLength;
            cursor = torusArbAngleTurn(curCell, layer, cursor, "ld", resTurnRad, width, (length-curLength)/2/math::pi/resTurnRad*360);
        } else {
            cursor = wire(curCell, layer, cursor, "l", length - curLength, width);
        }
    } else if (length - curLength >= meanderSegmentLength) {
        cursor = wire(curCell, layer, cursor, "r", meanderSegmentLength, width);
        curLength+=meanderSegmentLength;
        cursor = torusArbAngleTurn(curCell, layer, cursor, "rd", resTurnRad, width, (length-curLength)/2/math::pi/resTurnRad*360);
    } else {
        cursor = wire(curCell, layer, cursor, "r", length - curLength, width);
        curLength+=length - curLength;
    }
    
}


point addResonator(cell* curCell, point couplingPoint, int w_res, int g_res, double frequency, int tailLen, string direction, bool claw) {
   
    point cursor;
    cursor.set(couplingPoint.x(), couplingPoint.y()-w_res/2 - g_res);
    int length = length_from_frequency(frequency, claw)*1e3;
    
    int resTurnRad = 8*w_res;
    generateStructure(curCell, cursor, w_res, tailLen, length, resTurnRad, aux2);
    generateStructure(curCell, cursor, w_res+2*g_res, tailLen+g_res, length+g_res, resTurnRad, aux3);
    
    if (direction=="r") {
        rotateLayer(curCell, aux2, couplingPoint, 90);
        rotateLayer(curCell, aux3, couplingPoint, 90);
    } else if (direction=="l") {
        rotateLayer(curCell, aux2, couplingPoint, -90);
        rotateLayer(curCell, aux3, couplingPoint, -90);
    } else if (direction=="u") {
        rotateLayer(curCell, aux2, couplingPoint, 180);
        rotateLayer(curCell, aux3, couplingPoint, 180);
        mirrorLayer(curCell, aux2, couplingPoint, newPoint(couplingPoint.x(), couplingPoint.y()+100e3));
        mirrorLayer(curCell, aux3, couplingPoint, newPoint(couplingPoint.x(), couplingPoint.y()+100e3));
    }
    
    layout->booleanTool->boolOnLayer(M, aux2, M, "A+B", 0, 0, 0);
    layout->booleanTool->boolOnLayer(M, aux3, protect, "A+B", 0, 0, 0);
    
    clearAllAuxiliaryAux(curCell);
    
    point retPoint;
    retPoint.set(200e3+resTurnRad, -(g_res+w_res/2+resTurnRad+tailLen));
    return rotateVector(retPoint, couplingPoint, direction);
}


point addResonatorNoMeander(cell* curCell, point couplingPoint, int w_res, int g_res, double frequency, int tailLen, string direction, bool claw) {
    
    point cursor;
    cursor.set(couplingPoint.x(), couplingPoint.y()-w_res/2 - g_res);
    
    int length = length_from_frequency(frequency, claw)*1e3;
    int resTurnRad = 8*w_res;
    int curLength = 0;
    point start;
    start.set(cursor.x(), cursor.y());
    int layer = aux2;
    int width = w_res;
    int i;
    for (i=0; i<2; i++) {
        curLength = 0;
        cursor = wire(curCell, layer, start, "r", 200e3, width);
        curLength+=200e3;
        cursor = torusTurn(curCell, layer, cursor, "rd", resTurnRad, width);
        curLength+=resTurnRad*math::pi_2;
        cursor = wire(curCell, layer, cursor, "d", tailLen, width);
        curLength+=tailLen;
        
        cursor.set(start.x(), start.y());
        
        cursor = wire(curCell, layer, cursor, "l", 200e3, width);
        curLength+=200e3;
        cursor = torusTurn(curCell, layer, cursor, "ld", resTurnRad, width);
        curLength+=resTurnRad*math::pi_2;
        cursor = wire(curCell, layer, cursor, "d", length-curLength, width);
        width = 2*g_res+w_res;
        tailLen += g_res;
        length += g_res;
        layer = aux3;
    }
    
    if (direction=="r") {
        rotateLayer(curCell, aux2, couplingPoint, 90);
        rotateLayer(curCell, aux3, couplingPoint, 90);
    } else if (direction=="l") {
        rotateLayer(curCell, aux2, couplingPoint, -90);
        rotateLayer(curCell, aux3, couplingPoint, -90);
    } else if (direction=="u") {
        rotateLayer(curCell, aux2, couplingPoint, 180);
        rotateLayer(curCell, aux3, couplingPoint, 180);
        mirrorLayer(curCell, aux2, couplingPoint, newPoint(couplingPoint.x(), couplingPoint.y()+100e3));
        mirrorLayer(curCell, aux3, couplingPoint, newPoint(couplingPoint.x(), couplingPoint.y()+100e3));
    }
    
    layout->booleanTool->boolOnLayer(M, aux2, M, "A+B", 0, 0, 0);
    layout->booleanTool->boolOnLayer(M, aux3, protect, "A+B", 0, 0, 0);
    
    clearAllAuxiliaryAux(curCell);
    
    point retPoint;
    retPoint.set(200e3+resTurnRad, -(g_res+w_res/2+resTurnRad+tailLen));
    return rotateVector(retPoint, couplingPoint, direction);


}
