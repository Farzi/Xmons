/*
 Coupled lamda/4 resonator.
 
 Coupling point is in the center of coupling area, being offset to the edge of protect layer towards the feedline.
 Schematic:
 
 ===================== <- feedline
  ________x________    <- resonator coupling area 
 |                         |   x - coupling (base) point
*/



#include "wiring.layout"

    int meanderSegmentLength = 250e3;

// Using the fit for ɛ=11.45 and claw length of ~70 um
double clawPhaseShift(double frequency) {
    return 0.014+1.436*frequency;
}
    
int length_from_frequency(double frequency, bool claw,  int mode_N) {
    if (claw)
        return ((math::sqrt2/2*c/frequency/(math::sqrt(ɛ+1))/1e9)*1e6)*mode_N - 1./180.*clawPhaseShift(frequency)/frequency/1e9*c/2/math::sqrt(ɛ/2.+1./2.)/2.*1e6;
    else
        return ((math::sqrt2/2*c/frequency/(math::sqrt(ɛ+1))/1e9)*1e6)*mode_N;
}



void generateStructure(cell* curCell, point cursor,  int width, int tailLen, int length, int mode_N,  int resTurnRad, int layer) {
    
        int curLength = 0;
        point start;
        cursor.set(cursor.x(), cursor.y());
        
        
        int newVerticalSegmentLength = 0.25e6;
        int newHorizontalSegmentLength = length/mode_N*2 -2*resTurnRad*math::pi_2-newVerticalSegmentLength;
    
    cursor = wire(curCell, layer, cursor, "r", 0.4e6, width);
    curLength+=0.4e6;
    cursor = torusTurn(curCell, layer, cursor, "rd", resTurnRad, width);
    curLength+=resTurnRad*math::pi_2;
    cursor = wire(curCell, layer, cursor, "d", 0.1e6, width);
    curLength+=0.1e6;
    cursor = torusTurn(curCell, layer, cursor, "dr", resTurnRad, width);
    curLength+=resTurnRad*math::pi_2;
    cursor = wire(curCell, layer, cursor, "r", length/mode_N-curLength-resTurnRad*math::pi_2-newVerticalSegmentLength/2, width);
    cursor = torusTurn(curCell, layer, cursor, "rd", resTurnRad, width);
    cursor = wire(curCell, layer, cursor, "d", newVerticalSegmentLength/2, width);
    curLength = length/mode_N;
    
    for (int i=0; i<mode_N/2; i+=2) {
        
        cursor = wire(curCell, layer, cursor, "d", newVerticalSegmentLength/2, width);
        curLength+=newVerticalSegmentLength;
        cursor = torusTurn(curCell, layer, cursor, "dl", resTurnRad, width);
        curLength+=resTurnRad*math::pi_2;
        cursor = wire(curCell, layer, cursor, "l", newHorizontalSegmentLength, width);
        curLength+=newHorizontalSegmentLength;
        
        cursor = torusTurn(curCell, layer, cursor, "ld", resTurnRad, width);
        curLength+=resTurnRad*math::pi_2;
        cursor = wire(curCell, layer, cursor, "d", newVerticalSegmentLength, width);
        curLength+=newVerticalSegmentLength;
        cursor = torusTurn(curCell, layer, cursor, "dr", resTurnRad, width);
        curLength+=resTurnRad*math::pi_2;
        cursor = wire(curCell, layer, cursor, "r", newHorizontalSegmentLength, width);
        curLength+=newHorizontalSegmentLength;
        cursor = torusTurn(curCell, layer, cursor, "rd", resTurnRad, width);
        curLength+=resTurnRad*math::pi_2;
        cursor = wire(curCell, layer, cursor, "d", newVerticalSegmentLength/2, width);
        curLength+=newVerticalSegmentLength;
    }
    

    
}


point addResonator(cell* curCell, point couplingPoint, int w_res, int g_res, double frequency, int mode_N, int tailLen, string direction, bool claw) {
   
    point cursor;
    cursor.set(couplingPoint.x(), couplingPoint.y());
    int length = length_from_frequency(frequency, claw, mode_N)*1e3;
    
    int resTurnRad = 20*w_res;
    generateStructure(curCell, cursor, w_res, tailLen, length, mode_N, resTurnRad, aux2);
    generateStructure(curCell, cursor, w_res+2*g_res, tailLen, length, mode_N, resTurnRad, aux3);
    
    rotateLayer(curCell, aux2, couplingPoint, angleFromDirection(direction));
    rotateLayer(curCell, aux3, couplingPoint, angleFromDirection(direction));
    
        
    layout->booleanTool->boolOnLayer(M, aux2, M, "A+B", 0, 0, 0);
    layout->booleanTool->boolOnLayer(protect, aux3, protect, "A+B", 0, 0, 0);
    
    clearAllAuxiliaryAux(curCell);
    
    point retPoint;
    retPoint.set(200e3+resTurnRad, -(g_res+w_res/2+resTurnRad+tailLen));
    return rotateVector(retPoint, couplingPoint, direction);
}

